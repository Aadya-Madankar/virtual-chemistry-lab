<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
    <title>Virtual Chemistry Lab</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body, html, #root {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #171717; /* neutral-900 */
            touch-action: none;
            font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
        }
        canvas {
            outline: none;
            -webkit-tap-highlight-color: rgba(255, 255, 255, 0);
        }
        .animate-pulse-soft {
            animation: pulse-soft 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }
        @keyframes pulse-soft {
            0%, 100% { opacity: 1; }
            50% { opacity: .8; }
        }
        .text-glow {
            text-shadow: 0 0 15px currentColor;
        }
    </style>
    
    <!-- Import Map for Dependencies -->
    <script type="importmap">
    {
      "imports": {
        "react": "https://esm.sh/react@18.3.1",
        "react/jsx-runtime": "https://esm.sh/react@18.3.1/jsx-runtime?external=react",
        "react-dom/client": "https://esm.sh/react-dom@18.3.1/client?external=react",
        "react-dom": "https://esm.sh/react-dom@18.3.1?external=react",
        "three": "https://esm.sh/three@0.167.1",
        "@react-three/fiber": "https://esm.sh/@react-three/fiber@8.17.6?external=react,react-dom,three",
        "@react-three/drei": "https://esm.sh/@react-three/drei@9.112.0?external=react,react-dom,three,@react-three/fiber",
        "@mediapipe/tasks-vision": "https://esm.run/@mediapipe/tasks-vision@0.10.9",
        "lucide-react": "https://esm.sh/lucide-react@0.436.0?external=react"
      }
    }
    </script>
</head>
<body>
    <div id="root"></div>

    <script type="module">
        import React, { useState, useEffect, useRef, useMemo, useCallback } from 'react';
        import ReactDOM from 'react-dom/client';
        import * as THREE from 'three';
        import { Canvas, useFrame } from '@react-three/fiber';
        import { Loader, Cylinder, Text, Environment, Grid, PerspectiveCamera, Html, RoundedBox, Sphere } from '@react-three/drei';
        import { HandLandmarker, FilesetResolver } from '@mediapipe/tasks-vision';
        import { Beaker, Hand, Flame, Camera, FlaskConical, Atom } from 'lucide-react';

        // --- CONSTANTS & TYPES (Merged) ---

        // World Dimensions
        const TABLE_HEIGHT = 0;
        const TABLE_WIDTH = 7;
        const TABLE_DEPTH = 3;
        
        // Colors
        const COLORS = {
            left: '#ef4444', // Red
            right: '#3b82f6'  // Blue
        };

        // Updated with VIBRANT liquid colors for better visibility in beakers
        const CHEMICALS = {
            WATER: { name: 'Water', formula: 'H2O', color: '#a5f3fc', flameColor: undefined, ph: 7.0, volume: 90 },
            NACL: { name: 'Sodium Chloride', formula: 'NaCl', color: '#fefce8', flameColor: '#fbbf24', ph: 7.0, volume: 60 }, // Clearish Yellow
            KCL: { name: 'Potassium Chloride', formula: 'KCl', color: '#e9d5ff', flameColor: '#c084fc', ph: 7.0, volume: 60 }, // Light Purple
            BACL2: { name: 'Barium Chloride', formula: 'BaCl2', color: '#dcfce7', flameColor: '#a3e635', ph: 7.0, volume: 60 }, // Light Green
            CUCL: { name: 'Copper Chloride', formula: 'CuCl', color: '#06b6d4', flameColor: '#0ea5e9', ph: 7.0, volume: 60 }, // Teal
            RBCL: { name: 'Rubidium Chloride', formula: 'RbCl', color: '#fbcfe8', flameColor: '#be185d', ph: 7.0, volume: 60 }, // Pink
            PBNO3: { name: 'Lead Nitrate', formula: 'Pb(NO3)2', color: '#e2e8f0', flameColor: '#e0f2fe', ph: 7.0, volume: 60 }, // Whiteish
            FECL3: { name: 'Iron Chloride', formula: 'FeCl3', color: '#ca8a04', flameColor: '#eab308', ph: 7.0, volume: 60 }, // Gold/Amber
        };

        // --- HELPER FUNCTIONS ---
        
        // Blend multiple colors
        const blendColors = (colors) => {
            if (colors.length === 0) return null;
            const r = colors.reduce((acc, c) => acc + new THREE.Color(c).r, 0) / colors.length;
            const g = colors.reduce((acc, c) => acc + new THREE.Color(c).g, 0) / colors.length;
            const b = colors.reduce((acc, c) => acc + new THREE.Color(c).b, 0) / colors.length;
            return new THREE.Color(r, g, b);
        };

        const createBeaker = (id, x, chemicalKey) => ({
            id,
            type: chemicalKey === 'WATER' ? 'flask' : 'beaker',
            position: new THREE.Vector3(x, 0, 0),
            rotation: new THREE.Euler(0, 0, 0),
            contents: { ...CHEMICALS[chemicalKey] },
            isHovered: false
        });

        const createBurner = (id, x, z) => ({
            id,
            type: 'burner',
            position: new THREE.Vector3(x, 0, 0),
            rotation: new THREE.Euler(0, 0, 0),
            isHovered: false
        });

        const INITIAL_LAB_OBJECTS = [
            createBeaker('beaker-nacl', -3.0, 'NACL'),
            createBeaker('beaker-kcl', -2.2, 'KCL'),
            createBeaker('beaker-bacl2', -1.4, 'BACL2'),
            createBeaker('beaker-cucl', -0.6, 'CUCL'),
            createBurner('burner-main', 0.2, 0), 
            createBeaker('beaker-rbcl', 1.0, 'RBCL'),
            createBeaker('beaker-pbno3', 1.8, 'PBNO3'),
            createBeaker('beaker-fecl3', 2.6, 'FECL3'),
            createBeaker('flask-water', 3.6, 'WATER'),
        ];

        // --- HOOKS: useMediaPipe ---

        // Tuning for smoother, more relaxed interaction
        const MIN_ALPHA = 0.05; 
        const MAX_ALPHA = 0.6; // Slightly slower tracking for stability
        const VELOCITY_THRESHOLD = 0.5; 

        // Map 2D screen coords to 3D Table space
        const mapHandToWorld = (x, y) => {
            // Wider range for X to reach corners easier
            const worldX = (0.5 - x) * 12; 
            // Adjusted Y range to make dipping easier (lower floor)
            const worldY = 3.5 - (y * 3.5);
            const worldZ = 0;
            return new THREE.Vector3(worldX, worldY, worldZ);
        };

        const useMediaPipe = (videoRef) => {
            const [isModelLoaded, setIsModelLoaded] = useState(false);
            const [isCameraReady, setIsCameraReady] = useState(false);
            const [error, setError] = useState(null);

            const handsRef = useRef({ left: null, right: null });
            const lastResultsRef = useRef(null);
            const landmarkerRef = useRef(null);
            const requestRef = useRef(0);
            const isMounted = useRef(true);

            useEffect(() => {
                isMounted.current = true;
                const loadModel = async () => {
                    try {
                        const vision = await FilesetResolver.forVisionTasks(
                            "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.9/wasm"
                        );
                        if (!isMounted.current) return;
                        const landmarker = await HandLandmarker.createFromOptions(vision, {
                            baseOptions: {
                                modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
                                delegate: "GPU"
                            },
                            runningMode: "VIDEO",
                            numHands: 2,
                            minHandDetectionConfidence: 0.5,
                            minHandPresenceConfidence: 0.5,
                            minTrackingConfidence: 0.5
                        });

                        if (isMounted.current) {
                            landmarkerRef.current = landmarker;
                            setIsModelLoaded(true);
                        } else {
                            landmarker.close();
                        }
                    } catch (err) {
                        console.error("Model Loading Error:", err);
                        if (isMounted.current) setError(`Failed to load hand tracking model: ${err.message}`);
                    }
                };
                loadModel();
                return () => {
                    isMounted.current = false;
                    if (requestRef.current) cancelAnimationFrame(requestRef.current);
                    if (landmarkerRef.current) landmarkerRef.current.close();
                };
            }, []);

            const initializeCamera = useCallback(async () => {
                if (!isMounted.current) return;
                setError(null);
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({
                        video: { facingMode: 'user', width: { ideal: 640 }, height: { ideal: 480 } }
                    });
                    if (videoRef.current && isMounted.current) {
                        videoRef.current.srcObject = stream;
                        videoRef.current.onloadeddata = () => {
                            if (isMounted.current) {
                                setIsCameraReady(true);
                                predictWebcam();
                            }
                        };
                    }
                } catch (err) {
                    console.error("Camera Error:", err);
                    if (isMounted.current) {
                        setError(err.name === 'NotAllowedError' ? "Camera permission denied." : `Camera error: ${err.message}`);
                    }
                }
            }, [videoRef]);

            const predictWebcam = useCallback(() => {
                if (!videoRef.current || !landmarkerRef.current || !isMounted.current) return;
                const video = videoRef.current;
                if (video.videoWidth > 0 && video.videoHeight > 0) {
                    const startTimeMs = performance.now();
                    try {
                        const results = landmarkerRef.current.detectForVideo(video, startTimeMs);
                        lastResultsRef.current = results;
                        processResults(results);
                    } catch (e) {
                        console.warn("Detection failed", e);
                    }
                }
                requestRef.current = requestAnimationFrame(predictWebcam);
            }, [videoRef]);

            const processResults = (results) => {
                const newHands = { left: null, right: null };
                if (results.landmarks) {
                    for (let i = 0; i < results.landmarks.length; i++) {
                        const landmarksRaw = results.landmarks[i];
                        const classification = results.handedness[i][0];
                        const isRight = classification.categoryName === 'Right';
                        const side = isRight ? 'right' : 'left';
                        const landmarks3D = landmarksRaw.map(lm => mapHandToWorld(lm.x, lm.y));
                        let position = landmarks3D[0];
                        
                        // Adaptive Smoothing
                        const prevHand = handsRef.current[side];
                        if (prevHand) {
                            const dist = position.distanceTo(prevHand.position);
                            let alpha = THREE.MathUtils.mapLinear(Math.min(dist, VELOCITY_THRESHOLD), 0, VELOCITY_THRESHOLD, MIN_ALPHA, MAX_ALPHA);
                            position = prevHand.position.clone().lerp(position, alpha);
                            for (let j = 0; j < landmarks3D.length; j++) {
                                landmarks3D[j] = prevHand.landmarks[j].clone().lerp(landmarks3D[j], alpha);
                            }
                        }
                        
                        // Preserve existing coatings if hand is still tracked
                        const existingCoatings = prevHand ? prevHand.fingerCoatings : {};
                        newHands[side] = { position, landmarks: landmarks3D, fingerCoatings: existingCoatings };
                    }
                }
                handsRef.current = newHands;
            };

            return { isCameraReady, isModelLoaded, handsRef, lastResultsRef, error, initializeCamera };
        };

        // --- COMPONENTS ---

        // 1. Liquid Shader Material (Unchanged)
        const LiquidShaderMaterial = {
            uniforms: {
                uTime: { value: 0 },
                uColor: { value: new THREE.Color('#ffffff') },
                uFill: { value: 0.5 },
                uDisturbance: { value: 0.0 }
            },
            vertexShader: `
                varying vec2 vUv;
                varying vec3 vPosition;
                varying float vWave;
                uniform float uTime;
                uniform float uDisturbance;
                void main() {
                    vUv = uv;
                    vPosition = position;
                    vec3 pos = position;
                    if (pos.y > 0.48) {
                        float dist = distance(pos.xz, vec2(0.0));
                        float meniscus = smoothstep(0.3, 0.5, dist) * 0.05;
                        pos.y += meniscus;
                        float wave = sin(dist * 15.0 - uTime * 5.0) * 0.02 * uDisturbance;
                        wave += cos(pos.x * 20.0 + uTime * 3.0) * 0.01 * uDisturbance;
                        pos.y += wave;
                        vWave = wave;
                    }
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                }
            `,
            fragmentShader: `
                uniform vec3 uColor;
                uniform float uDisturbance;
                varying vec2 vUv;
                varying vec3 vPosition;
                varying float vWave;
                void main() {
                    vec3 finalColor = uColor;
                    if (vPosition.y > 0.45) {
                        float highlight = smoothstep(0.0, 0.02, vWave) * 0.3 * uDisturbance;
                        finalColor += highlight;
                        float fizz = smoothstep(0.4, 0.6, abs(sin(vUv.x * 20.0 + vWave * 10.0))) * 0.4 * uDisturbance;
                        finalColor += vec3(fizz);
                        float alpha = 0.8 + 0.2 * vUv.y;
                        gl_FragColor = vec4(finalColor, alpha);
                    } else {
                        float density = smoothstep(-0.5, 0.5, vPosition.y);
                        float bubbles = 0.0;
                        if (uDisturbance > 0.1) {
                             float noise = fract(sin(dot(vUv.xy * 10.0 ,vec2(12.9898,78.233))) * 43758.5453);
                             if (noise > 0.95) bubbles = 0.3 * uDisturbance;
                        }
                        gl_FragColor = vec4(finalColor * (0.8 + 0.2 * density) + bubbles, 0.9);
                    }
                }
            `
        };

        const BeakerMesh = ({ data }) => {
            const meshRef = useRef(null);
            const liquidMeshRef = useRef(null);
            const liquidMatRef = useRef(null);
            const outerGlassMatRef = useRef(null);

            const contents = data.contents;
            const fillPercentage = contents ? Math.max(0.01, contents.volume / 100) : 0;
            const liquidColor = contents ? new THREE.Color(contents.color) : new THREE.Color('#ffffff');
            
            useFrame((state) => {
                if (meshRef.current) {
                    meshRef.current.position.copy(data.position);
                    meshRef.current.rotation.copy(data.rotation);
                }
                if (outerGlassMatRef.current) {
                    const targetColor = data.isHovered ? new THREE.Color('#aaddff') : new THREE.Color('#ffffff');
                    const targetEmissive = data.isHovered ? 0.2 : 0;
                    outerGlassMatRef.current.color.lerp(targetColor, 0.2);
                    outerGlassMatRef.current.emissiveIntensity = THREE.MathUtils.lerp(outerGlassMatRef.current.emissiveIntensity, targetEmissive, 0.2);
                }
                if (liquidMeshRef.current && liquidMatRef.current) {
                     liquidMeshRef.current.scale.y = THREE.MathUtils.lerp(liquidMeshRef.current.scale.y, fillPercentage, 0.1);
                     liquidMatRef.current.uniforms.uTime.value = state.clock.elapsedTime;
                     liquidMatRef.current.uniforms.uColor.value.lerp(liquidColor, 0.1);
                     let targetDisturbance = data.isHovered ? 1.0 : 0.0;
                     liquidMatRef.current.uniforms.uDisturbance.value = THREE.MathUtils.lerp(liquidMatRef.current.uniforms.uDisturbance.value, targetDisturbance, 0.1);
                }
            });

            return React.createElement('group', { ref: meshRef },
                React.createElement(Cylinder, { args: [0.32, 0.32, 0.8, 32], position: [0, 0.4, 0] },
                    React.createElement('meshPhysicalMaterial', {
                        ref: outerGlassMatRef,
                        color: "#ffffff",
                        emissive: "#aaddff",
                        emissiveIntensity: 0,
                        transmission: 0.95,
                        roughness: 0.05,
                        metalness: 0.1,
                        ior: 1.5,
                        thickness: 0.05,
                        transparent: true,
                        opacity: 0.3,
                        side: THREE.FrontSide
                    })
                ),
                React.createElement(Cylinder, { args: [0.3, 0.3, 0.78, 32], position: [0, 0.41, 0] },
                    React.createElement('meshPhysicalMaterial', {
                        transmission: 0.9,
                        roughness: 0.1,
                        side: THREE.BackSide
                    })
                ),
                contents && contents.volume > 0 && React.createElement('group', { position: [0, 0.05, 0] },
                    React.createElement('mesh', { ref: liquidMeshRef, position: [0, 0.375 * fillPercentage, 0], scale: [1, fillPercentage, 1] },
                        React.createElement('cylinderGeometry', { args: [0.28, 0.28, 0.75, 32] }),
                        React.createElement('shaderMaterial', { ref: liquidMatRef, args: [LiquidShaderMaterial], transparent: true })
                    )
                ),
                React.createElement('group', { position: [0, 0.4, 0.325] },
                    [0.1, 0.3, 0.5].map((y, i) => 
                        React.createElement('mesh', { key: i, position: [0, y - 0.4, 0] },
                            React.createElement('planeGeometry', { args: [0.15, 0.01] }),
                            React.createElement('meshBasicMaterial', { color: "white", transparent: true, opacity: 0.5, side: THREE.DoubleSide })
                        )
                    )
                )
            );
        };

        // 2. Fire Shader Material
        const FireShaderMaterial = {
            uniforms: {
                uTime: { value: 0 },
                uColor: { value: new THREE.Color("#0066ff") },
                uCoreColor: { value: new THREE.Color("#ffffff") }
            },
            vertexShader: `
                varying vec2 vUv;
                varying float vNoise;
                uniform float uTime;
                float hash(vec2 p) { return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x)))); }
                float noise(vec2 x) {
                    vec2 i = floor(x);
                    vec2 f = fract(x);
                    float a = hash(i);
                    float b = hash(i + vec2(1.0, 0.0));
                    float c = hash(i + vec2(0.0, 1.0));
                    float d = hash(i + vec2(1.0, 1.0));
                    vec2 u = f * f * (3.0 - 2.0 * f);
                    return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
                }
                void main() {
                    vUv = uv;
                    vec3 pos = position;
                    float n = noise(vec2(pos.x * 5.0 + uTime, pos.y * 8.0 - uTime * 4.0));
                    vNoise = n;
                    float turbulence = smoothstep(0.0, 1.0, uv.y); 
                    pos.x += n * 0.1 * turbulence;
                    pos.z += n * 0.1 * turbulence;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                }
            `,
            fragmentShader: `
                varying vec2 vUv;
                varying float vNoise;
                uniform vec3 uColor;
                uniform vec3 uCoreColor;
                void main() {
                    float alpha = 1.0 - vUv.y;
                    alpha *= smoothstep(0.0, 0.2, vUv.y);
                    float dist = abs(vUv.x - 0.5);
                    float core = smoothstep(0.1, 0.0, dist);
                    vec3 finalColor = mix(uColor, uCoreColor, core * 0.8);
                    finalColor += vNoise * 0.2;
                    gl_FragColor = vec4(finalColor, alpha);
                }
            `
        };

        const ReactionParticles = ({ activeColor }) => {
            const sparkCount = 40;
            const sparkMesh = useRef(null);
            const dummy = useMemo(() => new THREE.Object3D(), []);
            const sparks = useRef(new Array(sparkCount).fill(0).map(() => ({
                pos: new THREE.Vector3(),
                vel: new THREE.Vector3(),
                life: 0,
                delay: Math.random() * 2
            })));

            useFrame((state, delta) => {
                if (sparkMesh.current) {
                    sparks.current.forEach((p, i) => {
                        if (p.delay > 0) {
                            p.delay -= delta;
                            p.pos.set(0, -100, 0);
                        } else {
                            if (p.life <= 0) {
                                p.life = 0.5 + Math.random() * 0.5;
                                const theta = Math.random() * Math.PI * 2;
                                const r = Math.random() * 0.1;
                                p.pos.set(r * Math.cos(theta), 0.8 + Math.random() * 0.3, r * Math.sin(theta));
                                p.vel.set((Math.random() - 0.5) * 1.5, 1.5 + Math.random() * 2.0, (Math.random() - 0.5) * 1.5);
                            }
                            p.pos.addScaledVector(p.vel, delta);
                            p.vel.y -= delta * 1.0;
                            p.life -= delta;
                            dummy.position.copy(p.pos);
                            const scale = (p.life / 1.0) * 0.6;
                            dummy.scale.setScalar(scale > 0 ? scale : 0);
                            dummy.updateMatrix();
                            sparkMesh.current.setMatrixAt(i, dummy.matrix);
                        }
                    });
                    sparkMesh.current.instanceMatrix.needsUpdate = true;
                    sparkMesh.current.visible = true;
                }
            });

            return React.createElement('instancedMesh', { ref: sparkMesh, args: [undefined, undefined, sparkCount] },
                React.createElement('dodecahedronGeometry', { args: [0.03, 0] }),
                React.createElement('meshBasicMaterial', { color: activeColor, toneMapped: false })
            );
        };

        const BunsenBurnerMesh = ({ data, activeColor }) => {
            const meshRef = useRef(null);
            const flameMatRef = useRef(null);
            const baseFlameColor = new THREE.Color("#0066ff");
            const targetColor = useRef(baseFlameColor.clone());

            useFrame((state) => {
                if (!meshRef.current) return;
                meshRef.current.position.copy(data.position);
                if (activeColor) targetColor.current.set(activeColor);
                else targetColor.current.lerp(baseFlameColor, 0.1);
                
                if (flameMatRef.current) {
                    flameMatRef.current.uniforms.uTime.value = state.clock.elapsedTime;
                    flameMatRef.current.uniforms.uColor.value.lerp(targetColor.current, 0.1);
                }
            });

            return React.createElement('group', { ref: meshRef },
                React.createElement('mesh', { position: [0, 0.05, 0] },
                    React.createElement('cylinderGeometry', { args: [0.3, 0.4, 0.1, 16] }),
                    React.createElement('meshStandardMaterial', { color: "#444", metalness: 0.8, roughness: 0.4 })
                ),
                React.createElement('mesh', { position: [0, 0.3, 0] },
                    React.createElement('cylinderGeometry', { args: [0.08, 0.08, 0.6, 16] }),
                    React.createElement('meshStandardMaterial', { color: "#888", metalness: 0.9, roughness: 0.3 })
                ),
                React.createElement('mesh', { position: [0, 1.1, 0] },
                    React.createElement('cylinderGeometry', { args: [0.0, 0.15, 1.2, 32, 8, true] }),
                    React.createElement('shaderMaterial', {
                        ref: flameMatRef,
                        args: [FireShaderMaterial],
                        transparent: true,
                        depthWrite: false,
                        side: THREE.DoubleSide,
                        blending: THREE.AdditiveBlending
                    })
                ),
                activeColor && React.createElement(ReactionParticles, { activeColor: activeColor }),
                React.createElement('pointLight', {
                    position: [0, 0.8, 0],
                    color: activeColor || "#0066ff",
                    intensity: activeColor ? 3 : 1.5,
                    distance: 4,
                    decay: 2
                })
            );
        };

        // 3. Hand Controller (Solid Glove Style - Improved)
        const SolidHand = ({ handsRef, side }) => {
            const groupRef = useRef(null);
            const jointMeshes = useRef([]);
            const boneMeshes = useRef([]);
            
            const gloveColor = side === 'left' ? '#b91c1c' : '#1d4ed8'; 
            
            const JOINTS = [[0, 1], [1, 2], [2, 3], [3, 4], [0, 5], [5, 6], [6, 7], [7, 8], [0, 9], [9, 10], [10, 11], [11, 12], [0, 13], [13, 14], [14, 15], [15, 16], [0, 17], [17, 18], [18, 19], [19, 20], [5, 9], [9, 13], [13, 17], [0, 5], [0, 17]];

            useFrame(() => {
                if (!groupRef.current) return;
                const hand = handsRef.current[side];
                if (!hand || !hand.landmarks) {
                    groupRef.current.visible = false;
                    return;
                }
                groupRef.current.visible = true;

                // Update Joint Spheres
                hand.landmarks.forEach((pos, i) => {
                    const mesh = jointMeshes.current[i];
                    if (mesh) {
                        mesh.position.set(pos.x, pos.y, pos.z);
                        let color = gloveColor;
                        let scale = 1.0;
                        
                        // Fingertips visual feedback
                        if ([4, 8, 12, 16, 20].includes(i)) {
                             // If coated, show the chemical color
                             if (hand.fingerCoatings && hand.fingerCoatings[i] && hand.fingerCoatings[i].size > 0) {
                                 const coatings = Array.from(hand.fingerCoatings[i]);
                                 const chemicalColors = coatings.map(name => {
                                     const chem = Object.values(CHEMICALS).find(c => c.name === name);
                                     return chem ? chem.flameColor : '#fff';
                                 });
                                 const blended = blendColors(chemicalColors);
                                 if (blended) {
                                     mesh.material.color.set(blended);
                                     mesh.material.emissive.set(blended);
                                     mesh.material.emissiveIntensity = 0.5;
                                     scale = 1.3;
                                 }
                             } else {
                                 mesh.material.color.set(gloveColor);
                                 mesh.material.emissive.setHex(0x000000);
                             }
                        } else {
                             mesh.material.color.set(gloveColor);
                        }
                        mesh.scale.setScalar(scale);
                    }
                });

                // Update Bone Cylinders
                const up = new THREE.Vector3(0, 1, 0);
                const dummyVec = new THREE.Vector3();
                JOINTS.forEach(([startIdx, endIdx], i) => {
                    const mesh = boneMeshes.current[i];
                    if (mesh) {
                        const start = hand.landmarks[startIdx];
                        const end = hand.landmarks[endIdx];
                        mesh.position.copy(start).add(end).multiplyScalar(0.5);
                        const dist = start.distanceTo(end);
                        // Taper bones slightly to look more natural
                        mesh.scale.set(1, dist, 1);
                        dummyVec.subVectors(end, start).normalize();
                        mesh.quaternion.setFromUnitVectors(up, dummyVec);
                    }
                });
            });

            const joints = useMemo(() => Array.from({ length: 21 }), []);

            return React.createElement('group', { ref: groupRef },
                // Joints
                joints.map((_, i) => React.createElement('mesh', { key: `j-${i}`, ref: el => jointMeshes.current[i] = el },
                    React.createElement('sphereGeometry', { args: [0.055, 16, 16] }), 
                    React.createElement('meshStandardMaterial', { color: gloveColor, roughness: 0.3, metalness: 0.1 })
                )),
                // Bones
                JOINTS.map((_, i) => React.createElement('mesh', { key: `b-${i}`, ref: el => boneMeshes.current[i] = el },
                    React.createElement('cylinderGeometry', { args: [0.045, 0.045, 1.0, 12] }),
                    React.createElement('meshStandardMaterial', { color: gloveColor, roughness: 0.3, metalness: 0.1 })
                ))
            );
        };

        // 4. Lab Scene & HUD
        const GameHUD = ({ handsRef, burnerState }) => {
            const [status, setStatus] = useState({ left: false, right: false, coatingCount: 0 });
            
            useEffect(() => {
                const interval = setInterval(() => {
                    const l = handsRef.current.left;
                    const r = handsRef.current.right;
                    let count = 0;
                    if (l && l.fingerCoatings) {
                        Object.values(l.fingerCoatings).forEach(set => count += set.size);
                    }
                    if (r && r.fingerCoatings) {
                        Object.values(r.fingerCoatings).forEach(set => count += set.size);
                    }
                    setStatus({ left: !!l, right: !!r, coatingCount: count });
                }, 150);
                return () => clearInterval(interval);
            }, []);

            return React.createElement(Html, { position: [0, 0, 0], fullscreen: true, style: { pointerEvents: 'none' } },
                // MOVED: Top Right
                React.createElement('div', { className: "absolute top-4 right-4 pointer-events-auto" },
                    React.createElement('div', { className: "bg-neutral-900/90 p-5 rounded-xl backdrop-blur border border-white/10 shadow-xl w-72 text-left" },
                        React.createElement('h3', { className: "text-yellow-400 font-bold mb-2 border-b border-white/10 pb-1 flex items-center gap-2" }, 
                            React.createElement(Atom, { size: 16 }), "Lab Controls"
                        ),
                        React.createElement('ul', { className: "space-y-2 text-xs text-neutral-200" },
                            React.createElement('li', null, React.createElement('strong', { className: "text-blue-400 block" }, "↔ Navigation"), "Move hands left/right to reach beakers."),
                            React.createElement('li', null, React.createElement('strong', { className: "text-orange-400 block" }, "↓ Interaction"), "Dip finger to coat. Touch flame to burn."),
                            React.createElement('li', null, React.createElement('strong', { className: "text-purple-400 block" }, "Mixing"), "Dip in multiple beakers to mix salts!")
                        ),
                        React.createElement('div', { className: "mt-4 pt-2 border-t border-white/10" },
                            React.createElement('div', { className: "grid grid-cols-2 gap-2 text-[10px]" },
                                React.createElement('div', { className: `px-2 py-1 rounded ${status.left || status.right ? 'bg-green-900/50 text-green-300' : 'bg-red-900/50 text-red-300'}` }, status.left || status.right ? 'HANDS DETECTED' : 'NO HANDS'),
                                React.createElement('div', { className: "bg-neutral-800 px-2 py-1 rounded text-purple-300" }, `COATINGS: ${status.coatingCount}`)
                            )
                        )
                    )
                ),
                
                // REACTION TEXT
                burnerState.isActive && React.createElement('div', { className: "absolute bottom-12 left-1/2 transform -translate-x-1/2 w-auto pointer-events-none" },
                    React.createElement('div', { className: "flex flex-col items-center gap-2" },
                        React.createElement('div', { className: "bg-black/90 backdrop-blur-md border border-orange-500/50 px-8 py-4 rounded-2xl text-center shadow-[0_0_40px_rgba(234,88,12,0.4)]" },
                            React.createElement('h4', { className: "text-orange-400 text-xs font-bold uppercase tracking-widest mb-1" }, "Reaction"),
                            React.createElement('div', { className: "text-2xl font-bold text-white flex items-center justify-center gap-2 whitespace-nowrap" },
                                // Chemical Formulas
                                burnerState.chemicals.map((chem, i) => React.createElement(React.Fragment, { key: i },
                                    React.createElement('span', { style: { color: chem.color, textShadow: '0 0 10px rgba(255,255,255,0.3)' } }, chem.formula),
                                    React.createElement('span', { className: "text-neutral-500 text-lg mx-1" }, "+")
                                )),
                                React.createElement('span', { className: "text-red-500 font-extrabold" }, "Heat"),
                                React.createElement('span', { className: "text-neutral-400 mx-2" }, "="),
                                // Emission Result
                                React.createElement('span', { className: "text-glow font-extrabold", style: { color: burnerState.flameColor } }, "Emission")
                            ),
                            // Simple text description underneath
                             React.createElement('div', { className: "text-xs text-neutral-400 mt-2" }, 
                                `${burnerState.chemicals.map(c => c.name).join(" + ")} + Heat`
                             )
                        )
                    )
                )
            );
        };

        const LabScene = ({ handsRef }) => {
            const objectsRef = useRef(INITIAL_LAB_OBJECTS.map(obj => ({
                ...obj,
                position: obj.position.clone(),
                rotation: obj.rotation.clone(),
            })));
            
            // Ref structure: { left: { [fingerIdx]: Set<ChemicalName> }, ... }
            const fingerCoatingsRef = useRef({ left: {}, right: {} });
            
            const [burnerState, setBurnerState] = useState({ isActive: false, flameColor: null, chemicals: [] });

            useFrame(() => {
                const hands = handsRef.current;
                const objs = objectsRef.current;
                const burner = objs.find(o => o.type === 'burner');
                
                let activeFlameColor = null;
                let activeChemicals = new Set(); // Use set to avoid dups in display

                objs.forEach(obj => obj.isHovered = false);

                ['left', 'right'].forEach(side => {
                    const hand = hands[side];
                    if (hand && hand.landmarks) {
                        // Ensure storage exists
                        if (!fingerCoatingsRef.current[side]) fingerCoatingsRef.current[side] = {};
                        if (!hand.fingerCoatings) hand.fingerCoatings = fingerCoatingsRef.current[side];

                        [4, 8, 12, 16, 20].forEach(idx => {
                            if (!fingerCoatingsRef.current[side][idx]) fingerCoatingsRef.current[side][idx] = new Set();
                            
                            const tipPos = hand.landmarks[idx];
                            
                            // 1. Coating Logic
                            objs.forEach(obj => {
                                if (obj.type === 'beaker' || obj.type === 'flask') {
                                    const dx = tipPos.x - obj.position.x;
                                    const dy = tipPos.y - obj.position.y;
                                    
                                    // Increased dipping hitbox for easier interaction
                                    const HITBOX_W = 0.35;
                                    const HITBOX_H_TOP = 1.0;
                                    const HITBOX_H_BOT = 0.05;

                                    if (Math.abs(dx) < HITBOX_W && dy < HITBOX_H_TOP && dy > HITBOX_H_BOT) {
                                        const liquidHeight = 0.05 + (0.75 * Math.min(obj.contents.volume/100, 1));
                                        if (dy < liquidHeight) {
                                            obj.isHovered = true;
                                            const currentSet = fingerCoatingsRef.current[side][idx];
                                            
                                            if (obj.contents.name.includes('Water')) {
                                                // Rinse
                                                currentSet.clear();
                                            } else if (obj.contents.flameColor) {
                                                // Add (Mix)
                                                currentSet.add(obj.contents.name);
                                            }
                                        }
                                    }
                                }
                            });

                            // 2. Burning Logic
                            if (burner) {
                                const dx = tipPos.x - burner.position.x;
                                const dy = tipPos.y - burner.position.y;
                                if (Math.abs(dx) < 0.3 && dy > 0.5 && dy < 2.0) {
                                    const coatings = fingerCoatingsRef.current[side][idx];
                                    if (coatings && coatings.size > 0) {
                                        coatings.forEach(chemName => {
                                            const chem = Object.values(CHEMICALS).find(c => c.name === chemName);
                                            if (chem) {
                                                activeChemicals.add(chem);
                                            }
                                        });
                                    }
                                }
                            }
                        });
                    }
                });
                
                // Calculate mixed flame color
                if (activeChemicals.size > 0) {
                    const chemArray = Array.from(activeChemicals);
                    const colors = chemArray.map(c => c.flameColor);
                    const mixed = blendColors(colors);
                    if (mixed) {
                        setBurnerState({ 
                            isActive: true, 
                            flameColor: `#${mixed.getHexString()}`, 
                            chemicals: chemArray 
                        });
                    }
                } else {
                    if (burnerState.isActive) {
                         setBurnerState({ isActive: false, flameColor: null, chemicals: [] });
                    }
                }
            });

            return React.createElement(React.Fragment, null,
                React.createElement(GameHUD, { handsRef: handsRef, burnerState: burnerState }),
                React.createElement(PerspectiveCamera, { makeDefault: true, position: [0, 2.0, 5.5], fov: 50, rotation: [-0.2, 0, 0] }),
                React.createElement('color', { attach: "background", args: ['#111'] }),
                React.createElement('ambientLight', { intensity: 0.4 }),
                React.createElement('spotLight', { position: [5, 10, 5], intensity: 100, castShadow: true }),
                React.createElement('spotLight', { position: [-5, 10, 5], intensity: 100, castShadow: true }),
                React.createElement(Environment, { preset: "night" }),
                React.createElement('mesh', { position: [0, TABLE_HEIGHT - 0.02, 0], rotation: [-Math.PI/2, 0, 0], receiveShadow: true },
                    React.createElement('planeGeometry', { args: [14, TABLE_DEPTH + 2] }),
                    React.createElement('meshStandardMaterial', { color: "#1a1a1a", roughness: 0.2, metalness: 0.5 })
                ),
                React.createElement('mesh', { position: [0, TABLE_HEIGHT - 1.52, 0] },
                    React.createElement('boxGeometry', { args: [12, 3, TABLE_DEPTH - 0.2] }),
                    React.createElement('meshStandardMaterial', { color: "#0f0f0f" })
                ),
                React.createElement(Grid, { position: [0, TABLE_HEIGHT + 0.01, 0], args: [12, 3], cellThickness: 0.05, cellColor: "#444", sectionSize: 1, sectionThickness: 0.1, sectionColor: "#333", fadeDistance: 10 }),
                objectsRef.current.map((obj, index) => 
                    React.createElement('group', { key: obj.id },
                        obj.type === 'burner' ? 
                            React.createElement(BunsenBurnerMesh, { data: obj, activeColor: burnerState.flameColor }) :
                            React.createElement('group', null,
                                React.createElement(BeakerMesh, { data: obj }),
                                // Labels
                                React.createElement(Text, {
                                    position: [obj.position.x, index % 2 === 0 ? 1.5 : 1.8, obj.position.z],
                                    fontSize: 0.14,
                                    color: obj.contents?.color || "#ffffff",
                                    anchorX: "center",
                                    anchorY: "bottom",
                                    maxWidth: 0.8,
                                    textAlign: "center",
                                    outlineWidth: 0.02,
                                    outlineColor: "#000"
                                }, obj.contents?.name),
                                React.createElement(Text, {
                                    position: [obj.position.x, (index % 2 === 0 ? 1.5 : 1.8) - 0.2, obj.position.z],
                                    fontSize: 0.1,
                                    color: "#aaa",
                                    anchorX: "center",
                                    anchorY: "bottom",
                                    outlineWidth: 0.01,
                                    outlineColor: "#000"
                                }, obj.contents?.formula || "")
                            )
                    )
                ),
                React.createElement(SolidHand, { handsRef: handsRef, side: "left" }),
                React.createElement(SolidHand, { handsRef: handsRef, side: "right" })
            );
        };

        // 5. Webcam Preview
        const WebcamPreview = ({ videoRef, resultsRef, isCameraReady }) => {
            const canvasRef = useRef(null);
            const HAND_CONNECTIONS = [[0, 1], [1, 2], [2, 3], [3, 4], [0, 5], [5, 6], [6, 7], [7, 8], [0, 9], [9, 10], [10, 11], [11, 12], [0, 13], [13, 14], [14, 15], [15, 16], [0, 17], [17, 18], [18, 19], [19, 20], [5, 9], [9, 13], [13, 17], [0, 5], [0, 17]];

            useEffect(() => {
                if (!isCameraReady) return;
                let animationFrameId;
                const render = () => {
                    const canvas = canvasRef.current;
                    const video = videoRef.current;
                    if (canvas && video && video.readyState >= 2) {
                        const ctx = canvas.getContext('2d');
                        if (ctx) {
                            if (canvas.width !== video.videoWidth) canvas.width = video.videoWidth;
                            if (canvas.height !== video.videoHeight) canvas.height = video.videoHeight;
                            ctx.clearRect(0, 0, canvas.width, canvas.height);
                            ctx.save();
                            ctx.scale(-1, 1);
                            ctx.translate(-canvas.width, 0);
                            ctx.globalAlpha = 0.4;
                            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                            ctx.restore();
                            ctx.globalAlpha = 1.0;

                            if (resultsRef.current && resultsRef.current.landmarks) {
                                for (let i = 0; i < resultsRef.current.landmarks.length; i++) {
                                    const landmarks = resultsRef.current.landmarks[i];
                                    const handedness = resultsRef.current.handedness[i]?.[0];
                                    if (!handedness) continue;
                                    const color = handedness.categoryName === 'Right' ? COLORS.right : COLORS.left;
                                    ctx.strokeStyle = color;
                                    ctx.fillStyle = color;
                                    ctx.lineWidth = 5;
                                    ctx.beginPath();
                                    for (const [start, end] of HAND_CONNECTIONS) {
                                        const p1 = landmarks[start];
                                        const p2 = landmarks[end];
                                        ctx.moveTo((1 - p1.x) * canvas.width, p1.y * canvas.height);
                                        ctx.lineTo((1 - p2.x) * canvas.width, p2.y * canvas.height);
                                    }
                                    ctx.stroke();
                                    const tip = landmarks[8];
                                    ctx.beginPath();
                                    ctx.fillStyle = 'white';
                                    ctx.arc((1 - tip.x) * canvas.width, tip.y * canvas.height, 8, 0, 2 * Math.PI);
                                    ctx.fill();
                                }
                            }
                        }
                    }
                    animationFrameId = requestAnimationFrame(render);
                };
                render();
                return () => cancelAnimationFrame(animationFrameId);
            }, [isCameraReady, videoRef, resultsRef]);

            if (!isCameraReady) return null;
            return React.createElement('div', { className: "fixed bottom-0 right-0 w-64 h-48 z-50 pointer-events-none" },
                React.createElement('div', { className: "absolute top-2 left-2 text-[10px] text-white/50 font-mono uppercase tracking-widest" }, "Tracking Feed"),
                React.createElement('canvas', { ref: canvasRef, className: "w-full h-full object-cover" })
            );
        };

        // --- MAIN APP ---

        const App = () => {
            const videoRef = useRef(null);
            const { isCameraReady, isModelLoaded, handsRef, lastResultsRef, error, initializeCamera } = useMediaPipe(videoRef);
            const [started, setStarted] = useState(false);

            return React.createElement('div', { className: "relative w-full h-screen bg-neutral-900 overflow-hidden font-sans select-none" },
                React.createElement('video', {
                    ref: videoRef,
                    className: "absolute opacity-0 pointer-events-none",
                    playsInline: true,
                    muted: true,
                    autoPlay: true,
                    style: { width: '640px', height: '480px' }
                }),
                React.createElement(Canvas, { shadows: true, dpr: [1, 2] },
                    started ? React.createElement(LabScene, { handsRef: handsRef }) : null
                ),
                React.createElement(WebcamPreview, { videoRef: videoRef, resultsRef: lastResultsRef, isCameraReady: isCameraReady }),
                !started && React.createElement('div', { className: "absolute inset-0 z-20 flex flex-col items-center justify-center bg-black/80 backdrop-blur-sm p-8" },
                    React.createElement('div', { className: "max-w-2xl w-full bg-neutral-800 p-8 rounded-2xl border border-neutral-700 shadow-2xl text-center" },
                        React.createElement('div', { className: "flex justify-center mb-6" },
                            React.createElement('div', { className: "bg-orange-600 p-4 rounded-full" },
                                React.createElement(Flame, { size: 48, className: "text-white" })
                            )
                        ),
                        React.createElement('h1', { className: "text-4xl font-bold text-white mb-4" }, "Flame Test Simulator"),
                        React.createElement('p', { className: "text-neutral-300 text-lg mb-8" }, "Perform virtual flame tests safely. Coat your fingers in metal salt solutions and ignite them in the Bunsen Burner."),
                        React.createElement('div', { className: "grid grid-cols-2 gap-4 text-left mb-8" },
                            React.createElement('div', { className: "bg-neutral-700/50 p-4 rounded-lg flex items-start gap-3" },
                                React.createElement(Hand, { className: "text-blue-400 mt-1" }),
                                React.createElement('div', null,
                                    React.createElement('h3', { className: "font-bold text-white" }, "1. Easy Control"),
                                    React.createElement('p', { className: "text-sm text-neutral-400" }, "Use Left (Red) or Right (Blue) hand. Move hand Down to dip/ignite.")
                                )
                            ),
                            React.createElement('div', { className: "bg-neutral-700/50 p-4 rounded-lg flex items-start gap-3" },
                                React.createElement(Flame, { className: "text-orange-400 mt-1" }),
                                React.createElement('div', null,
                                    React.createElement('h3', { className: "font-bold text-white" }, "2. Ignite"),
                                    React.createElement('p', { className: "text-sm text-neutral-400" }, "Touch the Bunsen Burner (Center) with coated fingers.")
                                )
                            )
                        ),
                        React.createElement('div', { className: "space-y-4" },
                            !isModelLoaded && !error && React.createElement('div', { className: "flex items-center justify-center gap-2 text-yellow-500 bg-yellow-900/20 p-3 rounded-xl border border-yellow-500/30" },
                                React.createElement('div', { className: "animate-spin h-4 w-4 border-2 border-current border-t-transparent rounded-full" }),
                                React.createElement('span', null, "Initializing AI Computer Vision...")
                            ),
                            isModelLoaded && !isCameraReady && !error && React.createElement('button', {
                                onClick: initializeCamera,
                                className: "w-full bg-emerald-600 hover:bg-emerald-500 text-white font-bold py-4 px-8 rounded-xl transition-all hover:scale-[1.02] flex items-center justify-center gap-2"
                            }, React.createElement(Camera, { size: 24 }), React.createElement('span', null, "Enable Camera Access")),
                            isCameraReady && React.createElement('button', {
                                onClick: () => setStarted(true),
                                className: "w-full bg-blue-600 hover:bg-blue-500 text-white font-bold py-4 px-8 rounded-xl transition-all hover:scale-[1.02] animate-pulse-soft"
                            }, "Enter Flame Lab"),
                            error && React.createElement('div', { className: "bg-red-900/50 border border-red-500/50 p-4 rounded-xl text-red-200 text-sm text-left" },
                                React.createElement('p', { className: "font-bold flex items-center gap-2 mb-2" },
                                    React.createElement('span', { className: "bg-red-500 text-white w-5 h-5 rounded-full flex items-center justify-center text-xs" }, "!"),
                                    "System Error"
                                ),
                                React.createElement('p', null, error),
                                React.createElement('button', { onClick: initializeCamera, className: "mt-3 px-4 py-2 bg-red-800 hover:bg-red-700 rounded text-xs font-bold uppercase tracking-wider" }, "Retry Connection")
                            )
                        )
                    )
                ),
                React.createElement(Loader)
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(React.createElement(App));
    </script>
</body>
</html>